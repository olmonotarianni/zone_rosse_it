<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zone Rosse</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        
        #map {
            height: 100vh;
            width: 100%;
        }
        
        .sidebar {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 350px;
            max-height: calc(100vh - 20px);
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            overflow-y: auto;
        }
        
        .sidebar-header {
            padding: 15px;
            border-bottom: 1px solid #eee;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
        }
        
        .sidebar-content {
            padding: 10px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .ordinance {
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .ordinance-header {
            background: #f0f0f0;
            padding: 8px;
            border-radius: 4px 4px 0 0;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .ordinance-header:hover {
            background: #e0e0e0;
        }
        
        .ordinance-title {
            cursor: pointer;
            flex-grow: 1;
        }
        
        .ordinance-content {
            display: none;
        }
        
        .zone {
            border-top: 1px solid #eee;
            margin: 0;
        }
        
        .zone-header {
            background: #f8f8f8;
            padding: 6px 12px;
            font-weight: 500;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .zone-header:hover {
            background: #eeeeee;
        }
        
        .zone-title {
            cursor: pointer;
            flex-grow: 1;
        }
        
        .zone-content {
            display: none;
            padding: 5px 0;
        }
        
        .street-item {
            padding: 4px 20px;
            font-size: 12px;
            border-left: 3px solid transparent;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .street-item:hover {
            background: #f0f0f0;
        }
        
        .street-name {
            cursor: pointer;
            flex-grow: 1;
        }
        
        .street-item.has-coords {
            border-left-color: #ff0000;
        }
        
        .street-item.intersection {
            border-left-color: #ff6600;
            font-weight: 500;
        }
        
        .street-item.no-coords {
            color: #999;
            border-left-color: #ccc;
        }
        
        .controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        
        .btn {
            padding: 5px 10px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .btn:hover {
            background: #f0f0f0;
        }
        
        .toggle-btn {
            padding: 2px 6px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            margin-left: 5px;
            min-width: 18px;
            height: 18px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .toggle-btn:hover {
            background: #f0f0f0;
        }
        
        .toggle-btn.active {
            background: #ff4444;
            color: white;
            border-color: #ff4444;
        }
        
        .stats {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" onclick="toggleSidebar()">
                <h3 style="margin: 0;">Zone rosse per ordinanza</h3>
                <span id="sidebar-toggle">▼</span>
            </div>
            <div class="controls" id="sidebar-controls">
                <button class="btn" onclick="toggleAllOrdinances()">Mostra tutte</button>
                <button class="btn" onclick="fitToVisible()">spiega-mappa</button>
            </div>
        </div>
        <div class="sidebar-content" id="sidebar-content">
            <div id="ordinances-list"></div>
            <div class="stats" id="stats"></div>
        </div>
    </div>
    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        const map = L.map('map').setView([41.9028, 12.4964], 12);
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        let coordinatesData = {};
        let allMarkers = [];
        let visibleMarkers = [];
        let ordinanceGroups = {};
        let streetMarkers = {}; // New: track markers by street

        // Load coordinates data
        coordinatesData = await fetch('./coordinates.json').then(response => response.json());

        function isValidCoordinate(coords) {
            if (!coords || coords.length !== 2) return false;
            const [lat, lon] = coords;
            return lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180 && lat !== 0 && lon !== 0;
        }

        function createMarker(coords, metadata, streetName, ordId, zoneName) {
            if (!isValidCoordinate(coords)) {
                return null;
            }

            const isIntersection = metadata.type === 'incrocio' && metadata.has_calculated_intersection;
            
            let marker;
            if (isIntersection) {
                // Intersection point - larger red marker
                const intersectionIcon = L.divIcon({
                    className: 'intersection-marker',
                    html: '<div style="background-color: #ff6600; width: 18px; height: 18px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.4);"></div>',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });
                marker = L.marker(coords, { icon: intersectionIcon });
            } else {
                // Regular street point - standard red marker
                marker = L.circleMarker(coords, {
                    radius: 5,
                    fillColor: '#ff0000',
                    color: '#ffffff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                });
            }
            
            // Add metadata to marker
            marker.ordId = ordId;
            marker.zoneName = zoneName;
            marker.streetName = streetName;
            marker.isIntersection = isIntersection;
            
            // Popup content
            let popupContent = `<strong>${streetName}</strong><br>`;
            popupContent += `<em>Zone:</em> ${zoneName}<br>`;
            popupContent += `<em>Ordinance:</em> ${ordId}<br>`;
            if (metadata.display_info) {
                popupContent += `<em>Info:</em> ${metadata.display_info}<br>`;
            }
            popupContent += `<em>Type:</em> ${metadata.type}<br>`;
            if (isIntersection) {
                popupContent += `<span style="color: #ff6600;">🎯 Calculated intersection point</span>`;
            }
            
            marker.bindPopup(popupContent);
            return marker;
        }

        function loadCoordinates() {
            let totalStreets = 0;
            let streetsWithCoords = 0;
            let intersectionCount = 0;
            let calculatedIntersections = 0;

            console.log('Loading coordinates data:', coordinatesData);

            for (const [ordId, ordData] of Object.entries(coordinatesData)) {
                console.log(`Processing ordinance: ${ordId}`);
                
                if (!ordinanceGroups[ordId]) {
                    ordinanceGroups[ordId] = {};
                }

                for (const [zoneName, streets] of Object.entries(ordData.zones)) {
                    console.log(`  Processing zone: ${zoneName}, streets:`, Object.keys(streets));
                    
                    if (!ordinanceGroups[ordId][zoneName]) {
                        ordinanceGroups[ordId][zoneName] = L.layerGroup();
                    }

                    for (const [streetName, streetData] of Object.entries(streets)) {
                        totalStreets++;
                        
                        // Initialize street marker tracking
                        const streetKey = `${ordId}-${zoneName}-${streetName}`;
                        streetMarkers[streetKey] = [];
                        
                        console.log(`    Processing street: ${streetName}`, streetData);
                        
                        // Process ANY street data, even if coordinates is null initially
                        if (streetData) {
                            // Handle case where coordinates might be null
                            if (streetData.coordinates && Array.isArray(streetData.coordinates) && streetData.coordinates.length > 0) {
                                streetsWithCoords++;
                                
                                // Check coordinate format - are they objects with type/coords or direct arrays?
                                const firstCoord = streetData.coordinates[0];
                                const isObjectFormat = firstCoord && typeof firstCoord === 'object' && firstCoord.coords;
                                const isDirectFormat = firstCoord && Array.isArray(firstCoord) && firstCoord.length === 2;
                                
                                console.log(`      Coordinate format for ${streetName}: ${isObjectFormat ? 'object' : isDirectFormat ? 'direct' : 'unknown'}`, firstCoord);
                                
                                if (streetData.metadata?.type === 'incrocio') {
                                    intersectionCount++;
                                    
                                    if (isObjectFormat) {
                                        // Look for calculated intersection point
                                        const intersectionCoord = streetData.coordinates.find(c => c.type === 'intersection');
                                        
                                        if (intersectionCoord) {
                                            // Show only the calculated intersection point
                                            calculatedIntersections++;
                                            const marker = createMarker(intersectionCoord.coords, streetData.metadata, streetName, ordId, zoneName);
                                            if (marker) {
                                                ordinanceGroups[ordId][zoneName].addLayer(marker);
                                                allMarkers.push(marker);
                                                streetMarkers[streetKey].push(marker);
                                                console.log(`      Added intersection marker for: ${streetName}`);
                                            }
                                        } else {
                                            // Show all intersection coordinates (fallback)
                                            streetData.coordinates.forEach((coordData, index) => {
                                                if (coordData && coordData.coords) {
                                                    const marker = createMarker(coordData.coords, streetData.metadata, streetName, ordId, zoneName);
                                                    if (marker) {
                                                        ordinanceGroups[ordId][zoneName].addLayer(marker);
                                                        allMarkers.push(marker);
                                                        streetMarkers[streetKey].push(marker);
                                                        console.log(`      Added intersection fallback marker ${index} for: ${streetName}`);
                                                    }
                                                }
                                            });
                                        }
                                    } else if (isDirectFormat) {
                                        // Direct format intersection (fallback)
                                        streetData.coordinates.forEach((coords, index) => {
                                            if (coords && Array.isArray(coords) && coords.length === 2) {
                                                const marker = createMarker(coords, streetData.metadata, streetName, ordId, zoneName);
                                                if (marker) {
                                                    ordinanceGroups[ordId][zoneName].addLayer(marker);
                                                    allMarkers.push(marker);
                                                    streetMarkers[streetKey].push(marker);
                                                    console.log(`      Added direct intersection marker ${index} for: ${streetName}`);
                                                }
                                            }
                                        });
                                    }
                                } else {
                                    // Regular street - handle both formats
                                    if (isObjectFormat) {
                                        // Object format: {type: "...", coords: [lat, lon]}
                                        streetData.coordinates.forEach((coordData, index) => {
                                            if (coordData && coordData.coords) {
                                                const marker = createMarker(coordData.coords, streetData.metadata, streetName, ordId, zoneName);
                                                if (marker) {
                                                    ordinanceGroups[ordId][zoneName].addLayer(marker);
                                                    allMarkers.push(marker);
                                                    streetMarkers[streetKey].push(marker);
                                                    console.log(`      Added object format marker ${index} for: ${streetName}`);
                                                }
                                            } else {
                                                console.log(`      Skipped null object coordinate ${index} for: ${streetName}`);
                                            }
                                        });
                                    } else if (isDirectFormat) {
                                        // Direct format: [lat, lon]
                                        streetData.coordinates.forEach((coords, index) => {
                                            if (coords && Array.isArray(coords) && coords.length === 2) {
                                                const marker = createMarker(coords, streetData.metadata, streetName, ordId, zoneName);
                                                if (marker) {
                                                    ordinanceGroups[ordId][zoneName].addLayer(marker);
                                                    allMarkers.push(marker);
                                                    streetMarkers[streetKey].push(marker);
                                                    console.log(`      Added direct format marker ${index} for: ${streetName}`);
                                                }
                                            } else {
                                                console.log(`      Skipped null direct coordinate ${index} for: ${streetName}`);
                                            }
                                        });
                                    } else {
                                        console.log(`      Unknown coordinate format for: ${streetName}`, streetData.coordinates);
                                    }
                                }
                            } else {
                                console.log(`    No valid coordinates for: ${streetName}`);
                            }
                        } else {
                            console.log(`    Null street data for: ${streetName}`);
                        }
                    }
                    
                    // Start with all zones visible
                    ordinanceGroups[ordId][zoneName].addTo(map);
                    console.log(`  Added zone ${zoneName} to map with ${ordinanceGroups[ordId][zoneName].getLayers().length} markers`);
                }
                console.log(`Finished processing ordinance ${ordId}`);
            }

            console.log(`Total markers created: ${allMarkers.length}`);

            // Update stats
            document.getElementById('stats').innerHTML = `
                <strong>Vie trovate:</strong> ${streetsWithCoords}/${totalStreets}<br>
                <strong>Incroci trovati:</strong> ${intersectionCount}/${calculatedIntersections}<br>
                <strong>Ordinanze:</strong> ${Object.keys(ordinanceGroups).length}<br>
            `;
            // <strong>Punti:</strong> ${allMarkers.length}
            

            // Create sidebar list
            createOrdinancesList();
            updateVisibleMarkers();
        }

        function createOrdinancesList() {
            const listDiv = document.getElementById('ordinances-list');
            
            for (const [ordId, ordData] of Object.entries(coordinatesData)) {
                const ordDiv = document.createElement('div');
                ordDiv.className = 'ordinance';
                
                const ordHeader = document.createElement('div');
                ordHeader.className = 'ordinance-header';
                
                const ordTitle = document.createElement('div');
                ordTitle.className = 'ordinance-title';
                ordTitle.textContent = `📋 Prot. n. ${ordData.metadata?.protocol || ordId} (${ordData.metadata?.date || 'N/A'})`;
                ordTitle.onclick = () => toggleOrdinanceExpansion(ordId);
                
                const ordToggle = document.createElement('button');
                ordToggle.className = 'toggle-btn active';
                ordToggle.textContent = '✓';
                ordToggle.title = 'Toggle visibility on map';
                ordToggle.onclick = (e) => {
                    e.stopPropagation();
                    toggleOrdinanceVisibility(ordId, ordToggle);
                };
                
                ordHeader.appendChild(ordTitle);
                ordHeader.appendChild(ordToggle);
                
                const ordContent = document.createElement('div');
                ordContent.className = 'ordinance-content';
                ordContent.id = `ord-${ordId}`;
                ordContent.style.display = 'none'; // Start collapsed
                
                for (const [zoneName, streets] of Object.entries(ordData.zones)) {
                    const zoneDiv = document.createElement('div');
                    zoneDiv.className = 'zone';
                    
                    const zoneHeader = document.createElement('div');
                    zoneHeader.className = 'zone-header';
                    
                    const zoneTitle = document.createElement('div');
                    zoneTitle.className = 'zone-title';
                    zoneTitle.textContent = `📍 ${zoneName}`;
                    zoneTitle.onclick = () => toggleZoneExpansion(ordId, zoneName);
                    
                    const zoneToggle = document.createElement('button');
                    zoneToggle.className = 'toggle-btn active';
                    zoneToggle.textContent = '✓';
                    zoneToggle.title = 'Toggle zone visibility on map';
                    zoneToggle.onclick = (e) => {
                        e.stopPropagation();
                        toggleZoneVisibility(ordId, zoneName, zoneToggle);
                    };
                    
                    zoneHeader.appendChild(zoneTitle);
                    zoneHeader.appendChild(zoneToggle);
                    
                    const zoneContent = document.createElement('div');
                    zoneContent.className = 'zone-content';
                    zoneContent.id = `zone-${ordId}-${zoneName}`;
                    zoneContent.style.display = 'none'; // Start collapsed
                    
                    for (const [streetName, streetData] of Object.entries(streets)) {
                        const streetDiv = document.createElement('div');
                        streetDiv.className = 'street-item';
                        
                        const streetNameDiv = document.createElement('div');
                        streetNameDiv.className = 'street-name';
                        
                        if (!streetData || !streetData.coordinates) {
                            streetDiv.className += ' no-coords';
                            streetNameDiv.textContent = `❌ ${streetName}`;
                        } else if (streetData.metadata?.type === 'incrocio') {
                            streetDiv.className += ' intersection';
                            streetNameDiv.textContent = `🎯 ${streetName}`;
                        } else {
                            streetDiv.className += ' has-coords';
                            streetNameDiv.textContent = `🔴 ${streetName}`;
                        }
                        
                        streetNameDiv.onclick = () => focusOnStreet(ordId, zoneName, streetName);
                        
                        const streetToggle = document.createElement('button');
                        if (streetData && streetData.coordinates && streetData.coordinates.length > 0) {
                            streetToggle.className = 'toggle-btn active';
                            streetToggle.textContent = '✓';
                            streetToggle.title = 'Toggle street visibility on map';
                            streetToggle.onclick = (e) => {
                                e.stopPropagation();
                                toggleStreetVisibility(ordId, zoneName, streetName, streetToggle);
                            };
                        } else {
                            streetToggle.className = 'toggle-btn';
                            streetToggle.textContent = '✗';
                            streetToggle.disabled = true;
                            streetToggle.title = 'No coordinates available';
                        }
                        
                        streetDiv.appendChild(streetNameDiv);
                        streetDiv.appendChild(streetToggle);
                        zoneContent.appendChild(streetDiv);
                    }
                    
                    zoneDiv.appendChild(zoneHeader);
                    zoneDiv.appendChild(zoneContent);
                    ordContent.appendChild(zoneDiv);
                }
                
                ordDiv.appendChild(ordHeader);
                ordDiv.appendChild(ordContent);
                listDiv.appendChild(ordDiv);
            }
        }

        function toggleOrdinanceExpansion(ordId) {
            const content = document.getElementById(`ord-${ordId}`);
            const isVisible = content.style.display !== 'none';
            content.style.display = isVisible ? 'none' : 'block';
        }

        function toggleOrdinanceVisibility(ordId, button) {
            const isVisible = button.classList.contains('active');
            const newState = !isVisible;
            
            // Update ordinance button
            button.classList.toggle('active', newState);
            button.textContent = newState ? '✓' : '☐';
            
            // Find the ordinance content div
            const ordinanceContent = document.getElementById(`ord-${ordId}`);
            
            // Update all zone buttons and their visibility
            for (const zoneName of Object.keys(ordinanceGroups[ordId])) {
                // Find zone header within this ordinance
                const zoneContent = document.getElementById(`zone-${ordId}-${zoneName}`);
                const zoneHeader = zoneContent.previousElementSibling; // The zone-header div
                const zoneButton = zoneHeader.querySelector('.toggle-btn');
                
                if (zoneButton) {
                    zoneButton.classList.toggle('active', newState);
                    zoneButton.textContent = newState ? '✓' : '☐';
                }
                
                if (newState) {
                    map.addLayer(ordinanceGroups[ordId][zoneName]);
                } else {
                    map.removeLayer(ordinanceGroups[ordId][zoneName]);
                }
                
                // Update all street buttons in this zone
                const streetButtons = zoneContent.querySelectorAll('.toggle-btn:not([disabled])');
                streetButtons.forEach(streetBtn => {
                    streetBtn.classList.toggle('active', newState);
                    streetBtn.textContent = newState ? '✓' : '☐';
                });
            }
            
            updateVisibleMarkers();
        }

        function toggleZoneExpansion(ordId, zoneName) {
            const content = document.getElementById(`zone-${ordId}-${zoneName}`);
            const isVisible = content.style.display !== 'none';
            content.style.display = isVisible ? 'none' : 'block';
        }

        function toggleZoneVisibility(ordId, zoneName, button) {
            const isVisible = button.classList.contains('active');
            const newState = !isVisible;
            
            // Update zone button
            button.classList.toggle('active', newState);
            button.textContent = newState ? '✓' : '☐';
            
            // Update map layer
            if (newState) {
                map.addLayer(ordinanceGroups[ordId][zoneName]);
            } else {
                map.removeLayer(ordinanceGroups[ordId][zoneName]);
            }
            
            // Update all street buttons in this zone
            const zoneContent = document.getElementById(`zone-${ordId}-${zoneName}`);
            const streetButtons = zoneContent.querySelectorAll('.toggle-btn:not([disabled])');
            streetButtons.forEach(streetBtn => {
                streetBtn.classList.toggle('active', newState);
                streetBtn.textContent = newState ? '✓' : '☐';
            });
            
            updateVisibleMarkers();
        }

        function toggleStreetVisibility(ordId, zoneName, streetName, button) {
            const streetKey = `${ordId}-${zoneName}-${streetName}`;
            const markers = streetMarkers[streetKey] || [];
            const isVisible = button.classList.contains('active');
            
            markers.forEach(marker => {
                if (isVisible) {
                    ordinanceGroups[ordId][zoneName].removeLayer(marker);
                } else {
                    ordinanceGroups[ordId][zoneName].addLayer(marker);
                }
            });
            
            button.classList.toggle('active');
            button.textContent = isVisible ? '☐' : '✓';
            updateVisibleMarkers();
        }

        function focusOnStreet(ordId, zoneName, streetName) {
            const streetKey = `${ordId}-${zoneName}-${streetName}`;
            const streetMarkersForStreet = streetMarkers[streetKey] || [];
            
            if (streetMarkersForStreet.length > 0) {
                const group = L.featureGroup(streetMarkersForStreet);
                map.fitBounds(group.getBounds().pad(0.1));
                
                // Open popup for first marker
                streetMarkersForStreet[0].openPopup();
            }
        }

        function toggleAllOrdinances() {
            const allOrdinanceButtons = document.querySelectorAll('.ordinance-header .toggle-btn');
            const allActive = Array.from(allOrdinanceButtons).every(btn => btn.classList.contains('active'));
            const newState = !allActive;
            
            // Update the Toggle All button text
            const toggleAllButton = document.querySelector('.controls .btn');
            toggleAllButton.textContent = newState ? 'mostra tutto' : 'nascondi tutto';
            
            // Update all ordinance buttons
            allOrdinanceButtons.forEach(button => {
                const ordId = button.closest('.ordinance').querySelector('.ordinance-title').textContent.replace('📋 ', '');
                
                // Update ordinance button
                button.classList.toggle('active', newState);
                button.textContent = newState ? '✓' : '☐';
                
                // Update all zones for this ordinance
                Object.keys(ordinanceGroups[ordId]).forEach(zoneName => {
                    // Find zone header and button
                    const zoneContent = document.getElementById(`zone-${ordId}-${zoneName}`);
                    const zoneHeader = zoneContent.previousElementSibling;
                    const zoneButton = zoneHeader.querySelector('.toggle-btn');
                    
                    if (zoneButton) {
                        zoneButton.classList.toggle('active', newState);
                        zoneButton.textContent = newState ? '✓' : '☐';
                    }
                    
                    // Update map layer
                    if (newState) {
                        map.addLayer(ordinanceGroups[ordId][zoneName]);
                    } else {
                        map.removeLayer(ordinanceGroups[ordId][zoneName]);
                    }
                    
                    // Update all street buttons in this zone
                    const streetButtons = zoneContent.querySelectorAll('.toggle-btn:not([disabled])');
                    streetButtons.forEach(streetBtn => {
                        streetBtn.classList.toggle('active', newState);
                        streetBtn.textContent = newState ? '✓' : '☐';
                    });
                });
            });
            
            updateVisibleMarkers();
        }

        function fitToVisible() {
            updateVisibleMarkers();
            if (visibleMarkers.length > 0) {
                const group = L.featureGroup(visibleMarkers);
                map.fitBounds(group.getBounds().pad(0.1));
            }
        }

        function updateVisibleMarkers() {
            visibleMarkers = allMarkers.filter(marker => map.hasLayer(marker) || marker._map);
        }

        function toggleSidebar() {
            const content = document.getElementById('sidebar-content');
            const controls = document.getElementById('sidebar-controls');
            const toggle = document.getElementById('sidebar-toggle');
            
            const isVisible = content.style.display !== 'none';
            
            content.style.display = isVisible ? 'none' : 'block';
            controls.style.display = isVisible ? 'none' : 'block';
            toggle.textContent = isVisible ? '▶' : '▼';
        }

        // Initialize
        loadCoordinates();
    </script>
</body>
</html>