<!DOCTYPE html>
<html>
<head>
    <title>Zone Rosse</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="viewer_style.css" />
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" onclick="toggleSidebar()">
                <h3 style="margin: 0;">Ordinanze</h3>
                <span id="sidebar-toggle" class="sidebar-toggle">‚ñº</span>
            </div>
            <div class="controls" id="sidebar-controls">
                <button class="btn" onclick="toggleAllOrdinances()">Mostra tutte</button>
                <button class="btn" onclick="fitToVisible()">Centra mappa</button>
            </div>
        </div>
        <div class="sidebar-content" id="sidebar-content">
            <div id="ordinances-list"></div>
            <div class="stats" id="stats"></div>
        </div>
    </div>

    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        const map = L.map('map').setView([41.9028, 12.4964], 12);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);

        let coordinatesData = {};
        let allLayers = [];
        let visibleLayers = [];
        let ordinanceGroups = {};
        let streetLayers = {};
        let bboxLayers = {};

        coordinatesData = await fetch('./coordinates_osm.json').then(response => response.json());

        function calculatePolygonArea(coordinates) {
            let area = 0;
            const n = coordinates.length;

            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                area += coordinates[i][1] * coordinates[j][0];
                area -= coordinates[j][1] * coordinates[i][0];
            }

            return Math.abs(area) / 2;
        }

        function getBoundingBoxArea(coordinates) {
            let minLat = Infinity, maxLat = -Infinity;
            let minLon = Infinity, maxLon = -Infinity;

            coordinates.forEach(coord => {
                minLat = Math.min(minLat, coord[0]);
                maxLat = Math.max(maxLat, coord[0]);
                minLon = Math.min(minLon, coord[1]);
                maxLon = Math.max(maxLon, coord[1]);
            });

            return (maxLat - minLat) * (maxLon - minLon);
        }

        function removeDuplicateGeometries(geometries) {
            const unique = [];
            const seen = new Set();
            
            geometries.forEach(geom => {
                const coordsString = JSON.stringify(geom.coordinates);
                if (!seen.has(coordsString)) {
                    seen.add(coordsString);
                    unique.push(geom);
                } else {
                    console.log('üîÑ Removed duplicate geometry');
                }
            });
            
            console.log(`üìä Duplicates removed: ${geometries.length} ‚Üí ${unique.length} geometries`);
            return unique;
        }

        // 2. Merge polygon fragments
        function mergePolygonFragments(geometries) {
            const polygons = geometries.filter(g => g.type === 'Polygon');
            const others = geometries.filter(g => g.type !== 'Polygon');
            
            if (polygons.length <= 1) {
                return geometries;
            }
            
            console.log(`üîß Attempting to merge ${polygons.length} polygon fragments`);
            
            // Collect all unique boundary points
            const allPoints = [];
            const pointSet = new Set();
            
            polygons.forEach(polygon => {
                const coords = polygon.coordinates[0];
                coords.forEach(coord => {
                    const pointKey = `${coord[0].toFixed(7)},${coord[1].toFixed(7)}`;
                    if (!pointSet.has(pointKey)) {
                        pointSet.add(pointKey);
                        allPoints.push(coord);
                    }
                });
            });
            
            if (allPoints.length < 3) {
                console.warn('‚ö†Ô∏è Not enough unique points for merged polygon');
                return geometries;
            }
            
            // Order points to form a proper polygon boundary
            try {
                // Calculate centroid
                const centerLat = allPoints.reduce((sum, p) => sum + p[0], 0) / allPoints.length;
                const centerLon = allPoints.reduce((sum, p) => sum + p[1], 0) / allPoints.length;
                
                // Sort points by angle from center
                const orderedPoints = allPoints.sort((a, b) => {
                    const angleA = Math.atan2(a[1] - centerLon, a[0] - centerLat);
                    const angleB = Math.atan2(b[1] - centerLon, b[0] - centerLat);
                    return angleA - angleB;
                });
                
                // Close the polygon
                if (orderedPoints.length > 0) {
                    const first = orderedPoints[0];
                    const last = orderedPoints[orderedPoints.length - 1];
                    if (Math.abs(first[0] - last[0]) > 0.00001 || Math.abs(first[1] - last[1]) > 0.00001) {
                        orderedPoints.push(orderedPoints[0]);
                    }
                }
                
                const mergedPolygon = {
                    type: 'Polygon',
                    coordinates: [orderedPoints],
                    mergedFromFragments: polygons.length
                };
                
                console.log(`‚úÖ Successfully merged into polygon with ${orderedPoints.length} points`);
                return [mergedPolygon, ...others];
                
            } catch (error) {
                console.error('‚ùå Failed to merge polygon fragments:', error);
                return geometries;
            }
        }

        function findOuterBoundarySmartMerging(geometries) {
            console.log(`üîç Finding outer boundary from ${geometries.length} geometries`);
            
            // First remove duplicates
            const uniqueGeometries = removeDuplicateGeometries(geometries);
            
            const closedGeometries = uniqueGeometries.filter(g => 
                (g.type === 'Polygon' || isClosedGeometry(g)) && 
                g.coordinates && g.coordinates.length > 0
            );

            console.log(`üîç Found ${closedGeometries.length} closed geometries`);

            if (closedGeometries.length === 0) return null;
            if (closedGeometries.length === 1) return closedGeometries[0];

            // For multiple polygons, analyze them carefully
            const polygons = closedGeometries.filter(g => g.type === 'Polygon');
            
            if (polygons.length > 1) {
                console.log(`üîß Analyzing ${polygons.length} polygons for potential merging`);
                
                // Calculate bounding box areas (more reliable for geographic coordinates)
                const polygonData = polygons.map((geom, index) => {
                    const coords = geom.coordinates[0];
                    const bboxArea = getBoundingBoxArea(coords);
                    const pointCount = coords.length;
                    return {
                        geometry: geom,
                        index: index,
                        bboxArea: bboxArea,
                        pointCount: pointCount,
                        coords: coords
                    };
                });
                
                // Sort by area (largest first)
                polygonData.sort((a, b) => b.bboxArea - a.bboxArea);
                
                const largest = polygonData[0];
                const smallest = polygonData[polygonData.length - 1];
                const areas = polygonData.map(p => p.bboxArea);
                const avgArea = areas.reduce((sum, area) => sum + area, 0) / areas.length;
                
                console.log(`üìä Polygon analysis:`);
                console.log(`   - Largest area: ${largest.bboxArea.toFixed(10)} (${largest.pointCount} points)`);
                console.log(`   - Smallest area: ${smallest.bboxArea.toFixed(10)} (${smallest.pointCount} points)`);
                console.log(`   - Average area: ${avgArea.toFixed(10)}`);
                console.log(`   - Size ratio: ${(largest.bboxArea / smallest.bboxArea).toFixed(2)}`);
                
                const sizeRatio = largest.bboxArea / smallest.bboxArea;
                
                // SMART DECISION LOGIC:
                
                // Case 1: One polygon is much larger than others (main square + decorative elements)
                // Don't merge - just use the largest
                if (sizeRatio > 30) {
                    console.log(`üèõÔ∏è Large main polygon detected (${sizeRatio.toFixed(1)}x larger) - using largest only`);
                    return largest.geometry;
                }
                
                // Case 2: All polygons are very small AND similar size (fragments)
                // Merge them together
                if (largest.bboxArea < 0.0001 && sizeRatio < 5) {
                    console.log(`üîß Small similar-sized fragments detected - merging`);
                    const merged = mergePolygonFragments(closedGeometries);
                    if (merged.length > 0 && merged[0].type === 'Polygon') {
                        console.log('‚úÖ Successfully merged fragments');
                        return merged[0];
                    }
                }
                
                // Case 3: check for fragment patterns
                if (sizeRatio < 10 && polygons.length >= 3) {
                    // Check if most polygons are small and similar
                    const smallPolygons = polygonData.filter(p => p.bboxArea < avgArea * 2);
                    const smallRatio = smallPolygons.length / polygonData.length;
                    
                    if (smallRatio > 0.7) { // 70%+ are small and similar
                        console.log(`üîß Fragment pattern detected (${smallPolygons.length}/${polygonData.length} small) - merging`);
                        const merged = mergePolygonFragments(closedGeometries);
                        if (merged.length > 0 && merged[0].type === 'Polygon') {
                            console.log('‚úÖ Successfully merged fragments');
                            return merged[0];
                        }
                    }
                }
                
                // Default: Use largest polygon
                console.log(`üìê Using largest polygon (no merging needed)`);
                return largest.geometry;
            }

            // Fallback to original logic for non-polygons
            console.log('üìê Using fallback: selecting largest geometry');
            let largestGeometry = null;
            let largestArea = 0;

            closedGeometries.forEach(geometry => {
                let coords;
                if (geometry.type === 'Polygon') {
                    coords = geometry.coordinates[0];
                } else {
                    coords = geometry.coordinates;
                }

                const area = getBoundingBoxArea(coords);

                if (area > largestArea) {
                    largestArea = area;
                    largestGeometry = geometry;
                }
            });

            return largestGeometry;
        }


function createSquarePolygon(geometries, metadata, streetName, ordId, zoneName) {
    console.log(`üèõÔ∏è Creating square layers for: ${streetName} with ${geometries.length} geometries`);
    
    const layers = [];
    const closedGeometries = geometries.filter(g => 
        g.type === 'Polygon' || isClosedGeometry(g)
    );
    
    const lineStringGeometries = geometries.filter(g => 
        g.type === 'LineString' && !isClosedGeometry(g)
    );

    console.log(`üèõÔ∏è Found ${closedGeometries.length} closed geometries and ${lineStringGeometries.length} LineStrings for ${streetName}`);

    // First, add all individual closed geometries (existing polygons)
    closedGeometries.forEach((geometry, index) => {
        try {
            let coords;
            if (geometry.type === 'Polygon') {
                coords = geometry.coordinates[0];
            } else {
                coords = geometry.coordinates;
            }

            if (!coords || coords.length < 3) {
                console.warn(`‚ùå Invalid coordinates for geometry ${index} of ${streetName}: coords=${coords?.length || 'null'}`);
                return;
            }

            // Validate each coordinate pair
            const validCoords = coords.filter(coord => {
                return Array.isArray(coord) && coord.length >= 2 && 
                       typeof coord[0] === 'number' && typeof coord[1] === 'number' &&
                       !isNaN(coord[0]) && !isNaN(coord[1]);
            });

            if (validCoords.length < 3) {
                console.warn(`‚ùå Not enough valid coordinates for geometry ${index} of ${streetName}: ${validCoords.length}/${coords.length}`);
                return;
            }

            console.log(`‚úÖ Creating perimeter polygon ${index + 1} for ${streetName} with ${validCoords.length} valid points`);
            console.log(`üîç Sample coordinates:`, validCoords.slice(0, 3));
            
            const latLngs = validCoords.map(coord => [coord[0], coord[1]]);

            const layer = L.polygon(latLngs, {
                color: '#dc3545',
                fillColor: '#dc3545',
                weight: 2,
                opacity: 0.8,
                fillOpacity: 0.2, // Lighter fill for perimeter polygons
                smoothFactor: 0.5
            });

            layer.ordId = ordId;
            layer.zoneName = zoneName;
            layer.streetName = streetName;
            layer.specType = metadata.type;
            layer.isSquareArea = true;
            layer.geometryType = 'Square/Perimeter';
            layer.geometryIndex = index;

            let popupContent = createStandardPopup(streetName, zoneName, ordId);
            popupContent += `<br><em>üìê Perimeter Polygon ${index + 1} (${validCoords.length} points)</em>`;
            
            layer.bindPopup(popupContent);
            layers.push(layer);
            
        } catch (error) {
            console.error(`‚ö†Ô∏è Failed to create layer for geometry ${index} of ${streetName}:`, error);
            console.log(`üîç Geometry data:`, geometry);
        }
    });

    // Second, try to find and fill inner areas surrounded by the polygons
    if (closedGeometries.length >= 3) {
        console.log(`üèõÔ∏è Attempting to find inner area surrounded by ${closedGeometries.length} perimeter polygons for ${streetName}`);
        
        const innerArea = findInnerAreaFromPerimeterPolygons(closedGeometries, streetName);
        
        if (innerArea && innerArea.length >= 3) {
            console.log(`‚úÖ Creating inner area polygon for ${streetName} with ${innerArea.length} points`);
            const latLngs = innerArea.map(coord => [coord[0], coord[1]]);

            const layer = L.polygon(latLngs, {
                color: '#dc3545', // Green for inner area
                fillColor: '#dc3545',
                weight: 3,
                opacity: 0.9,
                fillOpacity: 0.5, // More opaque for the actual square area
                smoothFactor: 0.5
            });

            layer.ordId = ordId;
            layer.zoneName = zoneName;
            layer.streetName = streetName;
            layer.specType = metadata.type;
            layer.isSquareArea = true;
            layer.geometryType = 'Square/InnerArea';
            layer.geometryIndex = 'inner';

            let popupContent = createStandardPopup(streetName, zoneName, ordId);
            popupContent += `<br><em>üèõÔ∏è Inner Square Area (${innerArea.length} points)</em>`;
            
            layer.bindPopup(popupContent);
            layers.push(layer);
        }
    }

    // Third, handle LineString segments (if any)
    if (lineStringGeometries.length > 0) {
        console.log(`üîó Attempting to connect ${lineStringGeometries.length} LineString segments for ${streetName}`);
        
        const connectedPolygons = connectLineStringsToPolygons(lineStringGeometries, streetName);
        
        connectedPolygons.forEach((polygon, index) => {
            console.log(`‚úÖ Creating connected polygon ${index + 1} for ${streetName} with ${polygon.length} points`);
            const latLngs = polygon.map(coord => [coord[0], coord[1]]);

            const layer = L.polygon(latLngs, {
                color: '#dc3545',
                fillColor: '#dc3545',
                weight: 2,
                opacity: 0.8,
                fillOpacity: 0.4,
                smoothFactor: 0.5
            });

            layer.ordId = ordId;
            layer.zoneName = zoneName;
            layer.streetName = streetName;
            layer.specType = metadata.type;
            layer.isSquareArea = true;
            layer.geometryType = 'Square/Connected';
            layer.geometryIndex = closedGeometries.length + index;

            let popupContent = createStandardPopup(streetName, zoneName, ordId);
            popupContent += `<br><em>üîó Connected Polygon ${index + 1} (${polygon.length} points)</em>`;
            
            layer.bindPopup(popupContent);
            layers.push(layer);
        });
    }

    console.log(`‚úÖ Created ${layers.length} total layers for ${streetName}`);
    
    return layers.length > 0 ? layers : null;
}

function findInnerAreaFromPerimeterPolygons(polygons, streetName) {
    if (polygons.length < 3) return null;
    
    // Get all coordinates from all polygons
    const allCoords = [];
    const perimeterCoords = [];
    
    polygons.forEach(polygon => {
        let coords;
        if (polygon.type === 'Polygon') {
            coords = polygon.coordinates[0];
        } else {
            coords = polygon.coordinates;
        }
        
        if (coords && coords.length > 0) {
            allCoords.push(...coords);
            perimeterCoords.push(coords);
        }
    });
    
    if (allCoords.length === 0) return null;
    
    // Find the centroid of all coordinates
    const centroid = findCentroid(allCoords);
    console.log(`üìç Centroid for ${streetName}:`, centroid);
    
    // For each polygon, find the points/edges that are closest to the centroid
    const innerPoints = [];
    
    perimeterCoords.forEach((coords, polygonIndex) => {
        const closestPoints = findClosestPointsToCenter(coords, centroid);
        innerPoints.push(...closestPoints);
        console.log(`üéØ Polygon ${polygonIndex + 1}: found ${closestPoints.length} inner points`);
    });
    
    if (innerPoints.length < 3) return null;
    
    // Create a convex hull from the inner points to form the inner area
    const innerBoundary = createConvexHull(innerPoints);
    
    // Ensure the polygon is closed
    if (innerBoundary.length >= 3) {
        const first = innerBoundary[0];
        const last = innerBoundary[innerBoundary.length - 1];
        if (!arePointsClose(first, last)) {
            innerBoundary.push(first); // Close the polygon
        }
    }
    
    console.log(`üèõÔ∏è Created inner boundary with ${innerBoundary.length} points for ${streetName}`);
    return innerBoundary;
}

function findCentroid(points) {
    const sum = points.reduce((acc, point) => {
        return [acc[0] + point[0], acc[1] + point[1]];
    }, [0, 0]);
    
    return [sum[0] / points.length, sum[1] / points.length];
}

function findClosestPointsToCenter(coords, centroid, maxPoints = 3) {
    // Calculate distances of all points to centroid
    const pointDistances = coords.map((point, index) => ({
        point: point,
        distance: Math.sqrt(Math.pow(point[0] - centroid[0], 2) + Math.pow(point[1] - centroid[1], 2)),
        index: index
    }));
    
    // Sort by distance and take the closest points
    pointDistances.sort((a, b) => a.distance - b.distance);
    
    // Take up to maxPoints closest points
    return pointDistances.slice(0, maxPoints).map(pd => pd.point);
}

function createConvexHull(points) {
    if (points.length < 3) return points;
    
    // Simple convex hull algorithm (Gift wrapping)
    // Find the leftmost point
    let leftmost = 0;
    for (let i = 1; i < points.length; i++) {
        if (points[i][1] < points[leftmost][1] || 
            (points[i][1] === points[leftmost][1] && points[i][0] < points[leftmost][0])) {
            leftmost = i;
        }
    }
    
    const hull = [];
    let current = leftmost;
    
    do {
        hull.push(points[current]);
        let next = (current + 1) % points.length;
        
        for (let i = 0; i < points.length; i++) {
            if (orientation(points[current], points[i], points[next]) === 2) {
                next = i;
            }
        }
        
        current = next;
    } while (current !== leftmost && hull.length < points.length);
    
    return hull;
}

function orientation(p, q, r) {
    const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
    if (val === 0) return 0; // collinear
    return (val > 0) ? 1 : 2; // clockwise or counterclockwise
}

function connectLineStringsToPolygons(lineStrings, streetName) {
    if (lineStrings.length === 0) return [];
    
    const polygons = [];
    const usedSegments = new Set();
    
    for (let i = 0; i < lineStrings.length; i++) {
        if (usedSegments.has(i)) continue;
        
        const polygon = buildPolygonFromSegment(lineStrings, i, usedSegments);
        if (polygon && polygon.length >= 3) {
            polygons.push(polygon);
            console.log(`üîó Built polygon from segments starting at ${i} for ${streetName}`);
        }
    }
    
    return polygons;
}

function buildPolygonFromSegment(lineStrings, startIndex, usedSegments) {
    const polygon = [];
    const currentSegment = lineStrings[startIndex];
    
    if (!currentSegment || !currentSegment.coordinates) return null;
    
    polygon.push(...currentSegment.coordinates);
    usedSegments.add(startIndex);
    
    let currentEndPoint = currentSegment.coordinates[currentSegment.coordinates.length - 1];
    const startPoint = currentSegment.coordinates[0];
    const maxIterations = lineStrings.length;
    let iterations = 0;
    
    while (iterations < maxIterations) {
        iterations++;
        
        if (arePointsClose(currentEndPoint, startPoint)) {
            if (!arePointsClose(polygon[polygon.length - 1], polygon[0])) {
                polygon.push(polygon[0]);
            }
            console.log(`‚úÖ Closed polygon with ${polygon.length} points`);
            return polygon;
        }
        
        let foundConnection = false;
        for (let j = 0; j < lineStrings.length; j++) {
            if (usedSegments.has(j)) continue;
            
            const segment = lineStrings[j];
            if (!segment || !segment.coordinates) continue;
            
            const segmentStart = segment.coordinates[0];
            const segmentEnd = segment.coordinates[segment.coordinates.length - 1];
            
            if (arePointsClose(currentEndPoint, segmentStart)) {
                polygon.push(...segment.coordinates.slice(1));
                currentEndPoint = segmentEnd;
                usedSegments.add(j);
                foundConnection = true;
                break;
            } else if (arePointsClose(currentEndPoint, segmentEnd)) {
                const reversedCoords = [...segment.coordinates].reverse();
                polygon.push(...reversedCoords.slice(1));
                currentEndPoint = segmentStart;
                usedSegments.add(j);
                foundConnection = true;
                break;
            }
        }
        
        if (!foundConnection) break;
    }
    
    if (polygon.length >= 3 && arePointsClose(currentEndPoint, startPoint)) {
        if (!arePointsClose(polygon[polygon.length - 1], polygon[0])) {
            polygon.push(polygon[0]);
        }
        console.log(`‚úÖ Created partial polygon with ${polygon.length} points`);
        return polygon;
    }
    
    return null;
}

function arePointsClose(point1, point2, threshold = 0.00001) {
    if (!point1 || !point2) return false;
    return Math.abs(point1[0] - point2[0]) < threshold && 
           Math.abs(point1[1] - point2[1]) < threshold;
}

function isClosedGeometry(geometry) {
    if (!geometry || !geometry.coordinates || geometry.coordinates.length < 3) {
        return false;
    }
    
    const coords = geometry.coordinates;
    const first = coords[0];
    const last = coords[coords.length - 1];
    
    const threshold = 0.00001;
    return Math.abs(first[0] - last[0]) < threshold && Math.abs(first[1] - last[1]) < threshold;
}

        // 5. UPDATED: Enhanced street geometry processing
        function processStreetGeometries(streetData, streetName, ordId, zoneName) {
            const layers = [];

            if (!streetData || (!streetData.geometries?.length && !streetData.special_coordinates?.length && !streetData.coordinates?.length)) {
                console.log(`‚ö†Ô∏è No data for ${streetName}`);
                return layers;
            }

            const metadata = streetData.metadata || {};
            const isCivic = metadata.type === 'civico'

            console.log(`üîç Processing ${streetName}: type=${metadata.type}, civic=${isCivic}`);

            // CIVIC ADDRESS HANDLING
            if (isCivic) {
                console.log(`üè† Processing civic address: ${streetName}`);
                
                let civicPoint = null;
                
                // Method 1: Check geometries for Point type
                if (streetData.geometries && streetData.geometries.length > 0) {
                    console.log(`üìç Checking ${streetData.geometries.length} geometries for civic point`);
                    for (const geom of streetData.geometries) {
                        if (geom.type === 'Point' && geom.coordinates && geom.coordinates.length >= 2) {
                            civicPoint = geom.coordinates;
                            console.log(`‚úÖ Found civic point in geometries: [${civicPoint[0]}, ${civicPoint[1]}]`);
                            break;
                        }
                    }
                }
                
                // Method 2: Check special_coordinates 
                if (!civicPoint && streetData.special_coordinates && streetData.special_coordinates.length > 0) {
                    console.log(`‚≠ê Checking ${streetData.special_coordinates.length} special coordinates for civic point`);
                    for (const special of streetData.special_coordinates) {
                        if (special.type === 'Point' && special.coordinates && special.coordinates.length >= 2) {
                            civicPoint = special.coordinates;
                            console.log(`‚úÖ Found civic point in special_coordinates: [${civicPoint[0]}, ${civicPoint[1]}]`);
                            break;
                        }
                    }
                }
                
                // Method 3: Check old format coordinates array
                if (!civicPoint && streetData.coordinates && streetData.coordinates.length > 0) {
                    console.log(`üìä Checking ${streetData.coordinates.length} old format coordinates for civic point`);
                    for (const coord of streetData.coordinates) {
                        if (Array.isArray(coord) && coord.length >= 2) {
                            civicPoint = coord;
                            console.log(`‚úÖ Found civic point in coordinates array: [${civicPoint[0]}, ${civicPoint[1]}]`);
                            break;
                        }
                    }
                }
                
                // Create civic marker if we found coordinates
                if (civicPoint) {
                    try {
                        const [lat, lon] = civicPoint;
                        console.log(`üéØ Creating civic marker at [${lat}, ${lon}]`);
                        
                        const marker = L.circle([lat, lon], {
                            radius: 30,
                            fillColor: '#dc3545',
                            color: '#dc3545',
                            weight: 2,
                            opacity: 0.8,
                            fillOpacity: 0.6
                        });

                        marker.ordId = ordId;
                        marker.zoneName = zoneName;
                        marker.streetName = streetName;
                        marker.isCivic = true;
                        marker.geometryType = 'Civic Point';

                        marker.bindPopup(createStandardPopup(streetName, zoneName, ordId) + 
                                    `<br><em>üè† Civic Address</em><br><em>üìç [${lat.toFixed(6)}, ${lon.toFixed(6)}]</em>`);

                        layers.push(marker);
                        console.log(`‚úÖ Civic marker created successfully for ${streetName}`);
                        return layers;
                        
                    } catch (error) {
                        console.error(`‚ùå Failed to create civic marker for ${streetName}:`, error);
                    }
                } else {
                    console.warn(`‚ö†Ô∏è No valid coordinates found for civic address: ${streetName}`);
                    console.log("   Geometry data:", streetData.geometries);
                    console.log("   Special data:", streetData.special_coordinates);
                    console.log("   Coordinates data:", streetData.coordinates);
                }
            }

            // NON-CIVIC PROCESSING (existing logic)
            const geometries = streetData.geometries || [];
            
            if (geometries.length === 0) {
                console.log(`‚ö†Ô∏è No geometries for non-civic: ${streetName}`);
                return layers;
            }

            const closedGeometries = geometries.filter(g => 
                g.type === 'Polygon' || isClosedGeometry(g)
            );

            // Detect if this should be treated as a square
            const isSquare = metadata.type === 'square' || 
                            streetName.toLowerCase().includes('piazza') ||
                            streetName.toLowerCase().includes('piazzale') ||
                            streetName.toLowerCase().includes('largo') ||
                            streetName.toLowerCase().includes('quartiere');

            if (isSquare && closedGeometries.length >= 1) {
                console.log(`üèõÔ∏è Treating ${streetName} as square with ${geometries.length} geometries`);
                const squareLayers = createSquarePolygon(geometries, metadata, streetName, ordId, zoneName);
                if (squareLayers && Array.isArray(squareLayers)) {
                    // Add each square layer to the main layers array
                    squareLayers.forEach(layer => {
                        layers.push(layer);
                    });
                    console.log(`‚úÖ Added ${squareLayers.length} square layers for ${streetName}`);
                } else {
                    console.warn(`‚ö†Ô∏è Failed to create square layers for ${streetName}`);
                }
            } else {
                console.log(`üõ£Ô∏è Treating ${streetName} as street with individual geometries`);
                geometries.forEach((geometry, index) => {
                    const layer = createPolyline(geometry, metadata, streetName, ordId, zoneName);
                    if (layer) {
                        layers.push(layer);
                    } else {
                        console.warn(`‚ö†Ô∏è Failed to create layer for geometry ${index} of ${streetName}`);
                    }
                });
            }

            return layers;
        }
   
        function createStandardPopup(streetName, zoneName, ordId) {
            const ordData = coordinatesData[ordId];
            const protocol = ordData?.metadata?.protocol || ordId;
            const date = ordData?.metadata?.date || '';
            const ordinanceTitle = `${protocol}${date ? ` (${date})` : ''}`;
            
            return `<strong>${streetName}</strong><br><em>Zona:</em> ${zoneName}<br><em>Ordinanza:</em> ${ordinanceTitle}`;
        }

        function createPolyline(geometry, metadata, streetName, ordId, zoneName) {
            if (!geometry || !geometry.coordinates || geometry.coordinates.length < 2) {
                return null;
            }

            const specType = metadata.type;
            const streetType = geometry.street_type || 'primary';

            let layer;

            if (geometry.type === 'Polygon') {
                const outerRing = geometry.coordinates[0];
                const latLngs = outerRing.map(coord => [coord[0], coord[1]]);

                layer = L.polygon(latLngs, {
                    color: '#dc3545',
                    fillColor: '#dc3545',
                    weight: 3,
                    opacity: 0.8,
                    fillOpacity: 0.3,
                    smoothFactor: 0.5
                });
            } else {
                const latLngs = geometry.coordinates.map(coord => [coord[0], coord[1]]);

                layer = L.polyline(latLngs, {
                    color: '#dc3545',
                    weight: 6,
                    opacity: 0.7
                });
            }

            layer.ordId = ordId;
            layer.zoneName = zoneName;
            layer.streetName = streetName;
            layer.specType = specType;
            layer.streetType = streetType;
            layer.geometryType = geometry.type;

            layer.bindPopup(createStandardPopup(streetName, zoneName, ordId));
            return layer;
        }

        function createSpecialMarker(special, metadata, streetName, ordId, zoneName) {
            if (!special || special.type !== 'Point' || !special.coordinates) {
                return null;
            }

            const [lat, lon] = special.coordinates;

            const marker = L.circle([lat, lon], {
                radius: 30,
                fillColor: '#dc3545',
                color: '#dc3545',
                weight: 2,
                opacity: 0.8,
                fillOpacity: 0.4
            });

            marker.ordId = ordId;
            marker.zoneName = zoneName;
            marker.streetName = streetName;
            marker.isSpecial = true;

            marker.bindPopup(createStandardPopup(streetName, zoneName, ordId));
            return marker;
        }

        function loadCoordinates() {
            let totalStreets = 0;
            let streetsWithGeometry = 0;
            let intersectionCount = 0;
            let tractCount = 0;
            let civicCount = 0;
            let totalGeometries = 0;
            let specialCount = 0;
            let squareCount = 0;

            for (const [ordId, ordData] of Object.entries(coordinatesData)) {
                if (!ordinanceGroups[ordId]) {
                    ordinanceGroups[ordId] = {};
                }

                for (const [zoneName, streets] of Object.entries(ordData.zones)) {
                    if (!ordinanceGroups[ordId][zoneName]) {
                        ordinanceGroups[ordId][zoneName] = L.layerGroup();
                    }

                    for (const [streetName, streetData] of Object.entries(streets)) {
                        totalStreets++;

                        const streetKey = `${ordId}-${zoneName}-${streetName}`;
                        streetLayers[streetKey] = [];

                        if (streetData) {
                            const hasGeometries = streetData.geometries && streetData.geometries.length > 0;
                            const hasSpecialCoords = streetData.special_coordinates && streetData.special_coordinates.length > 0;

                            if (hasGeometries || hasSpecialCoords) {
                                streetsWithGeometry++;

                                const specType = streetData.metadata?.type;
                                if (specType === 'incrocio') intersectionCount++;
                                if (specType === 'tratto') tractCount++;
                                if (specType === 'civico') civicCount++;

                                if (hasGeometries) {
                                    const layers = processStreetGeometries(streetData, streetName, ordId, zoneName);

                                    layers.forEach(layer => {
                                        ordinanceGroups[ordId][zoneName].addLayer(layer);
                                        allLayers.push(layer);
                                        streetLayers[streetKey].push(layer);

                                        if (layer.isSquareArea) {
                                            squareCount++;
                                        }
                                    });

                                    totalGeometries += streetData.geometries.length;
                                }

                                if (hasSpecialCoords) {
                                    streetData.special_coordinates.forEach((special) => {
                                        const marker = createSpecialMarker(special, streetData.metadata, streetName, ordId, zoneName);
                                        if (marker) {
                                            ordinanceGroups[ordId][zoneName].addLayer(marker);
                                            allLayers.push(marker);
                                            streetLayers[streetKey].push(marker);
                                            specialCount++;
                                        }
                                    });
                                }
                            }
                        }
                    }
                }
            }

            buildSidebar(totalStreets, streetsWithGeometry, intersectionCount, tractCount, civicCount, totalGeometries, specialCount, squareCount);
            hierarchicalController.initialize();
        }

        function buildSidebar(totalStreets, streetsWithGeometry, intersectionCount, tractCount, civicCount, totalGeometries, specialCount, squareCount) {
            const ordinancesList = document.getElementById('ordinances-list');
            ordinancesList.innerHTML = '';

            for (const [ordId, ordData] of Object.entries(coordinatesData)) {
                const ordDiv = document.createElement('div');
                ordDiv.className = 'ordinance-group';

                const protocol = ordData.metadata?.protocol || ordId;
                const date = ordData.metadata?.date || '';
                const ordinanceTitle = `${protocol}${date ? ` (${date})` : ''}`;

                const ordHeader = document.createElement('div');
                ordHeader.className = 'ordinance-header';
                ordHeader.innerHTML = `
                    <span class="ordinance-title">${ordinanceTitle}</span>
                    <button class="toggle-btn" data-ord="${ordId}">‚óè</button>
                `;

                const ordContent = document.createElement('div');
                ordContent.className = 'ordinance-content';
                ordContent.id = `ord-${ordId}`;

                for (const [zoneName, streets] of Object.entries(ordData.zones)) {
                    const zoneDiv = document.createElement('div');
                    zoneDiv.className = 'zone-group';

                    const zoneHeader = document.createElement('div');
                    zoneHeader.className = 'zone-header';
                    zoneHeader.innerHTML = `
                        <span class="zone-title">${zoneName}</span>
                        <button class="toggle-btn" data-zone="${ordId}-${zoneName}">‚óè</button>
                    `;

                    const zoneContent = document.createElement('div');
                    zoneContent.className = 'zone-content';
                    zoneContent.id = `zone-${ordId}-${zoneName}`;

                    for (const [streetName, streetData] of Object.entries(streets)) {
                        const streetDiv = document.createElement('div');
                        const hasGeometry = streetData && streetData.geometries && streetData.geometries.length > 0;
                        const hasSpecialCoords = streetData && streetData.special_coordinates && streetData.special_coordinates.length > 0;
                        const specType = streetData?.metadata?.type;
                        const displayMode = streetData?.metadata?.display_mode || 'normal';
                        const isComplete = streetData?.metadata?.intersection_complete !== false && 
                                         streetData?.metadata?.tract_complete !== false;

                        const isCleanSquare = hasGeometry && streetData.geometries.length > 1 && 
                                            streetData.geometries.some(g => g.type === 'Polygon' || isClosedGeometry(g));

                        let streetClass = 'street-item';
                        let displayIcon = '';

                        if (hasGeometry || hasSpecialCoords) {
                            if (isCleanSquare) {
                                streetClass += ' square-area';
                                displayIcon = ' üèõÔ∏è';
                            } else if (specType === 'incrocio') {
                                if (displayMode === 'intersection_only') {
                                    streetClass += ' intersection-point';
                                    displayIcon = ' üéØ';
                                } else {
                                    streetClass += isComplete ? ' intersection' : ' intersection-incomplete';
                                }
                            } else if (specType === 'civico') {
                                if (displayMode === 'civic_only') {
                                    streetClass += ' civic-point';
                                    displayIcon = ' üè†';
                                } else {
                                    streetClass += ' civic';
                                }
                            } else if (specType === 'tratto') {
                                if (displayMode === 'tract_only') {
                                    streetClass += ' tract-filtered';
                                    displayIcon = ' üìè';
                                } else {
                                    streetClass += isComplete ? ' tract' : ' tract-incomplete';
                                }
                            } else {
                                streetClass += ' has-geometry';
                            }
                        } else {
                            streetClass += ' no-geometry';
                        }

                        let validationIcon = '';
                        if (specType === 'incrocio' || specType === 'tratto') {
                            if (isComplete) {
                                validationIcon = ' ‚úì';
                            } else {
                                validationIcon = ' ‚ö†';
                            }
                        }

                        streetDiv.className = streetClass;
                        streetDiv.innerHTML = `
                            <span class="street-name">${streetName}${displayIcon}${validationIcon}</span>
                            <button class="toggle-btn" data-street="${ordId}-${zoneName}-${streetName}">‚óè</button>
                        `;
                        zoneContent.appendChild(streetDiv);
                    }

                    zoneDiv.appendChild(zoneHeader);
                    zoneDiv.appendChild(zoneContent);
                    ordContent.appendChild(zoneDiv);
                }

                ordDiv.appendChild(ordHeader);
                ordDiv.appendChild(ordContent);
                ordinancesList.appendChild(ordDiv);
            }

            document.getElementById('stats').innerHTML = `
                <strong>Statistics (OSM):</strong><br>
                üìã ${Object.keys(coordinatesData).length} ordinances<br>
                üèõÔ∏è ${streetsWithGeometry}/${totalStreets} streets with geometries<br>
                üìè ${totalGeometries} total geometries<br>
                üéØ ${intersectionCount} intersections<br>
                üè† ${civicCount} civic specifications<br>
                üìê ${tractCount} tract specifications<br>
                ‚≠ê ${specialCount} special coordinates<br>
                üèõÔ∏è ${squareCount} clean filled squares
            `;

            addEventListeners();
        }

        // ===== HIERARCHICAL BUTTON CONTROLLER =====
        class HierarchicalController {
            constructor() {
                this.hierarchy = [
                    {
                        selector: '.btn[onclick="toggleAllOrdinances()"]',
                        type: 'main',
                        children: '[data-ord]'
                    },
                    {
                        selector: '[data-ord]',
                        type: 'ordinance',
                        children: btn => `[data-zone^="${btn.dataset.ord}-"]`,
                        parent: '.btn[onclick="toggleAllOrdinances()"]'
                    },
                    {
                        selector: '[data-zone]',
                        type: 'zone',
                        children: btn => `[data-street^="${btn.dataset.zone}-"]`,
                        parent: btn => {
                            const ordId = btn.dataset.zone.split('-')[0];
                            return `[data-ord="${ordId}"]`;
                        }
                    },
                    {
                        selector: '[data-street]',
                        type: 'street',
                        parent: btn => {
                            const parts = btn.dataset.street.split('-');
                            const zoneId = parts.slice(0, -1).join('-');
                            return `[data-zone="${zoneId}"]`;
                        }
                    }
                ];
            }

            getHierarchyLevel(button) {
                return this.hierarchy.find(level => {
                    if (level.selector.includes('onclick')) {
                        return button.getAttribute('onclick') === 'toggleAllOrdinances()';
                    }
                    return button.matches(level.selector);
                });
            }

            getChildren(button) {
                const level = this.getHierarchyLevel(button);
                if (!level || !level.children) return [];

                const selector = typeof level.children === 'function' 
                    ? level.children(button) 
                    : level.children;
                
                return Array.from(document.querySelectorAll(selector));
            }

            getParent(button) {
                const level = this.getHierarchyLevel(button);
                if (!level || !level.parent) return null;

                const selector = typeof level.parent === 'function'
                    ? level.parent(button)
                    : level.parent;

                return document.querySelector(selector);
            }

            areAllChildrenActive(button) {
                const children = this.getChildren(button);
                return children.length > 0 && children.every(child => child.classList.contains('active'));
            }

            setButtonState(button, isActive) {
                if (isActive) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }

                if (button.getAttribute('onclick') === 'toggleAllOrdinances()') {
                    const allOrdinancesActive = this.areAllChildrenActive(button);
                    button.textContent = allOrdinancesActive ? 'Nascondi tutte' : 'Mostra tutte';
                }
            }

            updateParentState(button) {
                const parent = this.getParent(button);
                if (!parent) return;

                const shouldBeActive = this.areAllChildrenActive(parent);
                const currentlyActive = parent.classList.contains('active');

                if (shouldBeActive !== currentlyActive) {
                    this.setButtonState(parent, shouldBeActive);
                    this.updateParentState(parent);
                }
            }

            setAllDescendants(button, isActive) {
                const children = this.getChildren(button);
                
                children.forEach(child => {
                    this.setButtonState(child, isActive);
                    this.setAllDescendants(child, isActive);
                });
            }

            toggleMapLayers(button, isActive) {
                const level = this.getHierarchyLevel(button);
                
                switch(level.type) {
                    case 'main':
                        allLayers.forEach(layer => {
                            if (isActive && !map.hasLayer(layer)) {
                                map.addLayer(layer);
                            } else if (!isActive && map.hasLayer(layer)) {
                                map.removeLayer(layer);
                            }
                        });
                        break;

                    case 'ordinance':
                        const ordId = button.dataset.ord;
                        if (ordinanceGroups[ordId]) {
                            Object.values(ordinanceGroups[ordId]).forEach(layerGroup => {
                                if (isActive && !map.hasLayer(layerGroup)) {
                                    map.addLayer(layerGroup);
                                } else if (!isActive && map.hasLayer(layerGroup)) {
                                    map.removeLayer(layerGroup);
                                }
                            });
                        }
                        break;

                    case 'zone':
                        const parts = button.dataset.zone.split('-');
                        const zoneOrdId = parts[0];
                        const zoneName = parts.slice(1).join('-');
                        
                        if (ordinanceGroups[zoneOrdId] && ordinanceGroups[zoneOrdId][zoneName]) {
                            const layerGroup = ordinanceGroups[zoneOrdId][zoneName];
                            if (isActive && !map.hasLayer(layerGroup)) {
                                map.addLayer(layerGroup);
                            } else if (!isActive && map.hasLayer(layerGroup)) {
                                map.removeLayer(layerGroup);
                            }
                        }
                        break;

                    case 'street':
                        const streetKey = button.dataset.street;
                        const layers = streetLayers[streetKey];
                        if (layers) {
                            layers.forEach(layer => {
                                if (isActive && !map.hasLayer(layer)) {
                                    map.addLayer(layer);
                                } else if (!isActive && map.hasLayer(layer)) {
                                    map.removeLayer(layer);
                                }
                            });
                        }
                        break;
                }
            }

            getAllDescendants(button) {
                const children = this.getChildren(button);
                let descendants = [...children];
                
                children.forEach(child => {
                    descendants = descendants.concat(this.getAllDescendants(child));
                });
                
                return descendants;
            }

            toggle(button) {
                const wasActive = button.classList.contains('active');
                const newState = !wasActive;

                this.setButtonState(button, newState);
                this.toggleMapLayers(button, newState);
                this.setAllDescendants(button, newState);

                const descendants = this.getAllDescendants(button);
                descendants.forEach(descendant => {
                    this.toggleMapLayers(descendant, newState);
                });

                this.updateParentState(button);
                updateVisibleLayers();
            }

            initialize() {
                document.querySelectorAll('.toggle-btn').forEach(btn => {
                    btn.replaceWith(btn.cloneNode(true));
                });

                document.querySelectorAll('.toggle-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.toggle(btn);
                    });
                });

                const mainBtn = document.querySelector('.btn[onclick="toggleAllOrdinances()"]');
                if (mainBtn) {
                    mainBtn.onclick = () => this.toggle(mainBtn);
                }
            }
        }

        const hierarchicalController = new HierarchicalController();

        function addEventListeners() {
            document.querySelectorAll('.ordinance-header').forEach(header => {
                header.addEventListener('click', function() {
                    const content = this.nextElementSibling;
                    const isVisible = content.style.display === 'block';
                    content.style.display = isVisible ? 'none' : 'block';
                });
            });

            document.querySelectorAll('.zone-header').forEach(header => {
                header.addEventListener('click', function() {
                    const content = this.nextElementSibling;
                    const isVisible = content.style.display === 'block';
                    content.style.display = isVisible ? 'none' : 'block';
                });
            });

            document.querySelectorAll('.street-name').forEach(name => {
                name.addEventListener('click', function() {
                    const streetKey = this.nextElementSibling.dataset.street;
                    const layers = streetLayers[streetKey];
                    if (layers && layers.length > 0) {
                        const group = L.featureGroup(layers);
                        map.fitBounds(group.getBounds(), { padding: [20, 20] });
                    }
                });
            });

            hierarchicalController.initialize();
        }

        function toggleOrdinance(ordId, btn) {
            hierarchicalController.toggle(btn);
        }

        function toggleZone(zoneId, btn) {
            hierarchicalController.toggle(btn);
        }

        function toggleStreet(streetKey, btn) {
            hierarchicalController.toggle(btn);
        }

        function toggleAllOrdinances() {
            const mainBtn = document.querySelector('.btn[onclick="toggleAllOrdinances()"]');
            hierarchicalController.toggle(mainBtn);
        }

        function updateVisibleLayers() {
            visibleLayers = allLayers.filter(layer => map.hasLayer(layer));
        }

        function fitToVisible() {
            if (visibleLayers.length > 0) {
                const group = L.featureGroup(visibleLayers);
                map.fitBounds(group.getBounds(), { padding: [50, 50] });
            }
        }

        function toggleSidebar() {
            const content = document.getElementById('sidebar-content');
            const controls = document.getElementById('sidebar-controls');
            const toggle = document.getElementById('sidebar-toggle');

            const isVisible = content.style.display !== 'none';

            if (isVisible) {
                content.style.display = 'none';
                controls.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            } else {
                content.style.display = 'block';
                controls.style.display = 'flex';
                toggle.textContent = '‚ñº';
            }
        }

        // Initialize everything
        loadCoordinates();
    </script>
</body>
</html>